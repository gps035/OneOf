<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
using System;

namespace OneOf
{
<#
    for (var i = 1; i < 10; i++)
    {
        for (var type = 0; type < 2; type++)
        {
            var constructorName = type == 0 ? "OneOf" : "OneOfBase";
            var typeArguments = new List<string>();
            for (var j = 0; j < i; j++)
            {
                typeArguments.Add($"T{j}");
            }
            var typeName = constructorName + $"<{String.Join(", ", typeArguments)}>";
#>
    public <#=type == 0 ? "struct" : "class"#> <#=typeName#> : IOneOf
    {
        private readonly object _value;
        private readonly int _index;

        private <#=constructorName#>(object value, int index)
        {
            _value = value;
            _index = index;
        }

        object IOneOf.Value
            => _value;

        private T Get<T>(int index)
        {
            if (index != _index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{_index}");
            }
            return (T)_value;
        }
<#
            for (var j = 0; j < i; j++)
            {
#>

        public bool IsT<#=j#>
            => _index == <#=j#>;

        public T<#=j#> AsT<#=j#>
            => Get<T<#=j#>>(<#=j#>);

        public static implicit operator <#=typeName#> (T<#=j #> t)
            => new <#=typeName#>(t, <#=j#>);
<#
            }
            var switchArguments = new List<string>();
            for (var j = 0; j < i; j++)
            {
                switchArguments.Add($"Action<T{j}> f{j}");
            }
            var switchArgs = String.Join(", ", switchArguments);
#>

        public void Switch(<#=switchArgs#>)
        {
<#
            for (var j = 0; j < i; j++)
            {
#>
            if (IsT<#=j#> && f<#=j#> != null)
            {
                f<#=j#>(AsT<#=j#>);
                return;
            }

<#
            }
#>
            throw new InvalidOperationException();
        }

<#
            var matchArguments = new List<string>();
            for (var j = 0; j < i; j++)
            {
                matchArguments.Add($"Func<T{j}, TResult> f{j}");
            }
            var matchArgs = String.Join(", ", matchArguments);
#>
        public TResult Match<TResult>(<#=matchArgs#>)
        {
<#
            for (var j = 0; j < i; j++)
            {
#>
            if (IsT<#=j#> && f<#=j#> != null)
            {
                return f<#=j#>(AsT<#=j#>);
            }

<#
            }
#>
            throw new InvalidOperationException();
        }

<#
            const string ending = " = null, ";
            matchArgs = String.Join(ending, matchArguments) + ending + "Func<TResult> otherwise = null";
#>
        public TResult MatchSome<TResult>(<#=matchArgs#>)
        {
<#
            for (var j = 0; j < i; j++)
            {
#>
            if (IsT<#=j#> && f<#=j#> != null)
            {
                return f<#=j#>(AsT<#=j#>);
            }

<#
            }
#>
            if (otherwise != null)
            {
                return otherwise();
            }

            throw new InvalidOperationException();
        }
<#
            if(type == 1)
            {
#>

        protected <#=constructorName#>()
        {
            _value = this;
<#
                for (var j = 0; j < i; j++)
                {
#>

            if (this is T<#=j#>)
            {
                _index = <#=j#>;
            }
<#
                }
#>
        }
<#
            }
#>

        private bool Equals(<#=typeName#> other)
            => _index == other._index && Equals(_value, other._value);

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }
<#
            if(type == 1)
            {
#>

            if (ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as <#=typeName#>;
            return other != null && Equals(other);
<#
            }
            else
            {
#>

            return obj is <#=typeName#> && Equals((<#=typeName#>) obj);
<#
            }
#>
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return ((_value?.GetHashCode() ?? 0)*397) ^ _index;
            }
        }
    }

<#
        }
    }
#>
}
