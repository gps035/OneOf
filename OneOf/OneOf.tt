<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
using System;

namespace OneOf
{
<#
    for (var i = 1; i < 10; i++)
    {
        for (var type = 0; type < 2; type++)
        {
            var typeEnding = type == 0 ? "" : "Base";
            var structOrClass = type == 0 ? "struct" : "class";
            var typeArguments = new List<string>();
            for (var j = 0; j < i; j++)
            {
                typeArguments.Add($"T{j}");
            }
            var genericArg = String.Join(", ", typeArguments);
#>
    public <#=structOrClass#> OneOf<#=typeEnding#><<#= genericArg #>> : IOneOf
    {
        private readonly object _value;
        private readonly int _index;

        private OneOf<#=typeEnding#>(object value, int index)
        {
            _value = value;
            _index = index;
        }

        object IOneOf.Value
            => _value;

        private T Get<T>(int index)
        {
            if (index != _index)
            {
                throw new InvalidOperationException($"Cannot return as T{index} as result is T{_index}");
            }
            return (T)_value;
        }
<#
            for (var j = 0; j < i; j++)
            {
#>

        public bool IsT<#= j #>
            => _index == <#= j #>;

        public T<#= j #> AsT<#= j #>
            => Get<T<#= j #>>(<#= j #>);

        public static implicit operator OneOf<#=typeEnding#><<#= genericArg #>> (T<#=j #> t)
            => new OneOf<#=typeEnding#><<#= genericArg #>>(t, <#= j #>);
<#
            }
            var switchArguments = new List<string>();
            for (var j = 0; j < i; j++)
            {
                switchArguments.Add($"Action<T{j}> f{j}");
            }
            var matchArgList0 = String.Join(", ", switchArguments);
#>

        public void Switch(<#= matchArgList0 #>)
        {
<#
            for (var j = 0; j < i; j++)
            {
#>
            if (IsT<#= j #> && f<#= j #> != null)
            {
                f<#= j #>(AsT<#= j #>);
                return;
            }

<#
            }
#>
            throw new InvalidOperationException();
        }

<#
            var matchArguments = new List<string>();
            for (var j = 0; j < i; j++)
            {
                matchArguments.Add($"Func<T{j}, TResult> f{j}");
            }
            var matchArgList = String.Join(", ", matchArguments);
#>
        public TResult Match<TResult>(<#= matchArgList #>)
        {
<#
            for (var j = 0; j < i; j++)
            {
#>
            if (IsT<#= j #> && f<#= j #> != null)
            {
                return f<#= j #>(AsT<#= j #>);
            }

<#
            }
#>
            throw new InvalidOperationException();
        }

<#
            matchArgList = String.Join(" = null, ", matchArguments);
#>
        public TResult MatchSome<TResult>(<#= matchArgList #> = null, Func<TResult> otherwise = null)
        {
<#
            for (var j = 0; j < i; j++)
            {
#>
            if (IsT<#= j #> && f<#= j #> != null)
            {
                return f<#= j #>(AsT<#= j #>);
            }

<#
            }
#>
            if (otherwise != null)
            {
                return otherwise();
            }

            throw new InvalidOperationException();
        }
<#
            if(type == 1)
            {
#>

        protected OneOfBase()
        {
            _value = this;
<#
                for (var j = 0; j < i; j++)
                {
#>

            if (this is T<#= j #>)
            {
                _index = <#= j #>;
            }
<#
                }
#>
        }
<#
            }
#>

        private bool Equals(OneOf<#=typeEnding#><<#=genericArg #>> other)
            => _index == other._index && Equals(_value, other._value);

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }
<#
            if(type == 1)
            {
#>

            if (ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as OneOfBase<<#=genericArg#>>;
            return other != null && Equals(other);
<#
            }
            else
            {
#>

            return obj is OneOf<#=typeEnding#><<#=genericArg #>> && Equals((OneOf<#=typeEnding#><<#=genericArg #>>) obj);
<#
            }
#>
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return ((_value?.GetHashCode() ?? 0)*397) ^ _index;
            }
        }
    }

<#
        }
    }
#>
}
